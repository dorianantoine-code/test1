## Migration plan : clé élève `(ed_eleve_id, etablissement)` + table de liaison `compte_eleve`

Ce fichier contient les requêtes SQL **à appliquer manuellement** (ordre logique). Elles supposent Postgres/Supabase.

### 0. Sauvegarde
- Exporter les tables concernées (`eleve`, `devoir`, `fiche_devoir`, `agenda_perso`, `coef_matiere`, `compte`) avant toute modif.

### 1. Nouvelle table de liaison compte ↔ élève
```sql
create table if not exists public.compte_eleve (
  ed_account_id bigint not null references public.compte(ed_account_id) on delete cascade,
  ed_eleve_id bigint not null,
  etablissement text not null,
  created_at timestamptz not null default now(),
  constraint compte_eleve_pkey primary key (ed_account_id, ed_eleve_id, etablissement)
);
```

### 2. Préparer les tables enfants : ajout colonne etablissement (si manquante)
```sql
alter table public.devoir add column if not exists etablissement text;
alter table public.fiche_devoir add column if not exists etablissement text;
alter table public.agenda_perso add column if not exists etablissement text;
alter table public.coef_matiere add column if not exists etablissement text;
alter table public.eleve add column if not exists etablissement text; -- au cas où absente
```

### 3. Backfill `etablissement` via `eleve`
> Si un `ed_eleve_id` est présent dans plusieurs établissements, il faudra dupliquer les lignes concernées manuellement selon le mapping réel.
```sql
update public.devoir d
set etablissement = e.etablissement
from public.eleve e
where d.ed_eleve_id = e.ed_eleve_id and d.etablissement is null;

update public.fiche_devoir f
set etablissement = e.etablissement
from public.eleve e
where f.ed_eleve_id = e.ed_eleve_id and f.etablissement is null;

update public.agenda_perso a
set etablissement = e.etablissement
from public.eleve e
where a.ed_eleve_id = e.ed_eleve_id and a.etablissement is null;

update public.coef_matiere c
set etablissement = e.etablissement
from public.eleve e
where c.ed_eleve_id = e.ed_eleve_id and c.etablissement is null;
```

### 4. Peupler `compte_eleve`
- Vérifier d’abord qu’aucun élève n’a `etablissement` NULL (sinon corriger/dupliquer au bon établissement) :
```sql
select ed_eleve_id, ed_account_id, prenom, nom from public.eleve where etablissement is null;
```
- Si vous acceptez de ne peupler que les lignes avec établissement non NULL :
```sql
insert into public.compte_eleve (ed_account_id, ed_eleve_id, etablissement)
select distinct e.ed_account_id, e.ed_eleve_id, e.etablissement
from public.eleve e
where e.ed_account_id is not null
  and e.etablissement is not null
on conflict do nothing;
```

### 5. Contraintes PK/UK basées sur `(ed_eleve_id, etablissement)`
> Important : commencer par DROP les FK enfants qui pointent vers `eleve` avant de changer le PK.
```sql
-- Drop FK enfants existants (ordre : enfants -> parent)
alter table public.devoir drop constraint if exists devoir_ed_eleve_id_fkey;
alter table public.fiche_devoir drop constraint if exists fiche_devoir_ed_eleve_id_fkey;
alter table public.agenda_perso drop constraint if exists agenda_perso_ed_eleve_fk;
alter table public.coef_matiere drop constraint if exists coef_matiere_ed_eleve_fk;

-- eleve : nouveau PK composite
-- ⚠️ S'assurer qu'aucune ligne eleve n'a etablissement NULL avant ces deux lignes :
-- select ed_eleve_id, prenom, nom from public.eleve where etablissement is null;
-- Mettre à jour/manuellement celles qui sont NULL (par la vraie valeur ou une valeur provisoire si vraiment inconnu).
alter table public.eleve drop constraint if exists eleve_pkey;
alter table public.eleve add constraint eleve_pkey primary key (ed_eleve_id, etablissement);

-- devoir : PK + FK
alter table public.devoir drop constraint if exists devoir_pkey;
alter table public.devoir add constraint devoir_pkey primary key (ed_eleve_id, etablissement, ed_devoir_id);
alter table public.devoir add constraint devoir_ele_fk foreign key (ed_eleve_id, etablissement) references public.eleve(ed_eleve_id, etablissement) on delete cascade;

-- (si un unique index/contrainte existant reste en double-clé, le supprimer pour éviter les conflits type "devoir_unique_double")
do $$
declare r record;
begin
  for r in (
    select conname from pg_constraint
    where conrelid = 'public.devoir'::regclass and contype = 'u'
      and conkey = array[
        (select attnum from pg_attribute where attrelid='public.devoir'::regclass and attname='ed_eleve_id'),
        (select attnum from pg_attribute where attrelid='public.devoir'::regclass and attname='ed_devoir_id')
      ]
  ) loop
    execute format('alter table public.devoir drop constraint %I', r.conname);
  end loop;
end$$;

-- fiche_devoir : FK
alter table public.fiche_devoir add constraint fiche_devoir_ele_fk foreign key (ed_eleve_id, etablissement) references public.eleve(ed_eleve_id, etablissement) on delete cascade;

-- agenda_perso : PK inchangé + FK
alter table public.agenda_perso drop constraint if exists agenda_perso_pkey;
alter table public.agenda_perso add constraint agenda_perso_pkey primary key (id);
alter table public.agenda_perso add constraint agenda_perso_ele_fk foreign key (ed_eleve_id, etablissement) references public.eleve(ed_eleve_id, etablissement) on delete cascade;

-- coef_matiere : PK + FK
-- (si une PK existe déjà sous un autre nom, la supprimer d'abord)
do $$
declare r record;
begin
  for r in (
    select conname from pg_constraint
    where conrelid = 'public.coef_matiere'::regclass and contype = 'p'
  ) loop
    execute format('alter table public.coef_matiere drop constraint %I', r.conname);
  end loop;
end$$;
alter table public.coef_matiere add constraint coef_matiere_pkey primary key (ed_eleve_id, etablissement, code_matiere);
alter table public.coef_matiere add constraint coef_matiere_ele_fk foreign key (ed_eleve_id, etablissement) references public.eleve(ed_eleve_id, etablissement) on delete cascade;
```

### 6. Nettoyage colonnes `ed_account_id` des enfants (optionnel une fois le code adapté)
```sql
alter table public.devoir drop column if exists ed_account_id;
alter table public.agenda_perso drop column if exists ed_account_id;
alter table public.coef_matiere drop column if exists ed_account_id;
alter table public.eleve drop column if exists ed_account_id;
```

### 7. Rendre `etablissement` NOT NULL (après backfill et duplication éventuelle)
```sql
alter table public.devoir alter column etablissement set not null;
alter table public.fiche_devoir alter column etablissement set not null;
alter table public.agenda_perso alter column etablissement set not null;
alter table public.coef_matiere alter column etablissement set not null;
alter table public.eleve alter column etablissement set not null;
```

### 8. Vérifications
- Compter lignes avant/après.
- Vérifier qu’un élève présent via plusieurs comptes est bien listé dans `compte_eleve`.
- Vérifier qu’un devoir est accessible via `(ed_eleve_id, etablissement)` sans dépendre de `ed_account_id`.

### 9. Correctif `etablissement = idEtablissement`
Si l’établissement a été peuplé avec le nom au lieu de l’identifiant, corriger les tables (exemple via `raw` stocké) :
```sql
update public.eleve
set etablissement = 5;

update public.devoir d
set etablissement = e.etablissement
from public.eleve e
where d.ed_eleve_id = e.ed_eleve_id;

update public.agenda_perso a
set etablissement = e.etablissement
from public.eleve e
where a.ed_eleve_id = e.ed_eleve_id;

update public.coef_matiere c
set etablissement = e.etablissement
from public.eleve e
where c.ed_eleve_id = e.ed_eleve_id;

update public.fiche_devoir f
set etablissement = e.etablissement
from public.eleve e
where f.ed_eleve_id = e.ed_eleve_id;
```
